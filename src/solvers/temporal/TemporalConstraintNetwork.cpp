#include "TemporalConstraintNetwork.hpp"
#include <graph_analysis/WeightedEdge.hpp>
#include <graph_analysis/algorithms/FloydWarshall.hpp>
#include <graph_analysis/GraphIO.hpp>
#include <limits>
#include <boost/lexical_cast.hpp>
#include <numeric/Combinatorics.hpp>

#include "point_algebra/TimePointComparator.hpp"
#include "../csp/TemporalConstraintNetwork.hpp"
#include "QualitativeTemporalConstraintNetwork.hpp"

using namespace templ::solvers::temporal::point_algebra;
using namespace graph_analysis;


namespace templ {
namespace solvers {
namespace temporal {

TemporalConstraintNetwork::TemporalConstraintNetwork()
    : mpDistanceGraph( BaseGraph::getInstance() )
{}

TemporalConstraintNetwork::~TemporalConstraintNetwork()
{}

TemporalConstraintNetwork::TemporalConstraintNetwork(const TemporalConstraintNetwork& other)
    : ConstraintNetwork(other)
    , mpDistanceGraph(other.mpDistanceGraph->cloneEdges())
{}


/**
 * Get the known and consolidated constraint between two timepoints
 * \return consolidated timepoint constraint
 */
point_algebra::QualitativeTimePointConstraint::Type TemporalConstraintNetwork::getQualitativeConstraint(const point_algebra::TimePoint::Ptr& t1, const point_algebra::TimePoint::Ptr& t2)
{
    if(t1 == t2)
    {
        return point_algebra::QualitativeTimePointConstraint::Universal;
    } else {
        return point_algebra::QualitativeTimePointConstraint::Empty;
    }
}

// stp(N) is generated by upper-lower bounds of range on disjunctive intervals
void TemporalConstraintNetwork::stpWithConjunctiveIntervals()
{
    BaseGraph::Ptr graph = mpDistanceGraph->copy();

    TemporalConstraintNetwork tcn;

    EdgeIterator::Ptr edgeIt = graph->getEdgeIterator();

    IntervalConstraint::Ptr edge;
    double max, min;
    while (edgeIt->next())
    {
        // for each edge of the temp.const.network, check each interval and find the
        // highest min bound and the lowest max bound
        edge = dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );
        max = std::numeric_limits<double>::max();
        min = std::numeric_limits<double>::min();

        std::vector<Bounds> intervals = edge->getIntervals();
        std::vector<Bounds>::const_iterator cit = intervals.begin();
        for( ; cit != intervals.end(); ++cit)
        {
            min = std::max(cit->getLowerBound(), min);
            max = std::min(cit->getUpperBound(), max);
        }

        // create a new interval constraint using only the interval [min,max]
        IntervalConstraint::Ptr i(new IntervalConstraint(edge->getSourceTimePoint(),edge->getTargetTimePoint()));
        i->addInterval(Bounds(min,max));
        tcn.addIntervalConstraint(i);
    }
    // update mpDistanceGraph with the one that we just created (tcn)
    mpDistanceGraph = tcn.mpDistanceGraph->copy();
}

// stp(N) is generated by upper-lower bounds of range on disjunctive intervals
void TemporalConstraintNetwork::stp()
{
    // see Processing disjunctions in temporal constraint networks, (Schwalb and Dechter, 1997)
    // Upper-Lower-Tightening

    BaseGraph::Ptr graph = mpDistanceGraph->copy();

    TemporalConstraintNetwork tcn;

    EdgeIterator::Ptr edgeIt = graph->getEdgeIterator();

    IntervalConstraint::Ptr edge;
    double max, min;
    while (edgeIt->next())
    {
        // for each edge of the temp.const.network, check each interval and find the
        // highest min bound and the lowest max bound
        edge = dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );

        min = std::numeric_limits<double>::max();
        max = std::numeric_limits<double>::min();

        std::vector<Bounds> intervals = edge->getIntervals();
        std::vector<Bounds>::const_iterator cit = intervals.begin();
        for( ; cit != intervals.end(); ++cit)
        {
            min = std::min(cit->getLowerBound(), min);
            max = std::max(cit->getUpperBound(), max);
        }

        // create a new interval constraint using only the interval [min,max]
        IntervalConstraint::Ptr i = make_shared<IntervalConstraint>(edge->getSourceTimePoint(),edge->getTargetTimePoint());
        i->addInterval(Bounds(min, std::max(max, min + 1E-06)) );
        tcn.addIntervalConstraint(i);
    }
    // update mpDistanceGraph with the one that we just created (tcn)
    mpDistanceGraph = tcn.mpDistanceGraph->copy();
}

// the intersection between a temporal constraint network and a simple temporal constraint network
graph_analysis::BaseGraph::Ptr TemporalConstraintNetwork::intersection(graph_analysis::BaseGraph::Ptr other)
{
    //// complex temporal constraint network
    //BaseGraph::Ptr graph0 = mpDistanceGraph->copy();

    //// simple temporal constraint network
    //BaseGraph::Ptr graph1 = other->copy();

    // the intersection result
    TemporalConstraintNetwork tcn;

    EdgeIterator::Ptr edgeIt1 = other->getEdgeIterator();
    TimePoint::Ptr source,target;
    IntervalConstraint::Ptr edge0,edge1;

    // iterate through the simple temporal constraint network
    while (edgeIt1->next())
    {
        edge1 = dynamic_pointer_cast<IntervalConstraint>( edgeIt1->current() );
        source = edge1 -> getSourceTimePoint();
        target = edge1 -> getTargetTimePoint();

        std::vector<Bounds> intervals = edge1->getIntervals();
        std::vector<Bounds>::iterator interval = intervals.begin();

        EdgeIterator::Ptr edgeIt0 = mpDistanceGraph->getEdgeIterator();
        // for each edge from the simple temporal constraint network; iterate through the complex temporal constraint network
        while (edgeIt0->next())
        {
            // if we find two edges (one from each graph) which have the same source and target variables
            // then we look at their upper and lower bounds
            edge0 = dynamic_pointer_cast<IntervalConstraint>( edgeIt0->current() );
            if (target == edge0->getTargetTimePoint() && source == edge0->getSourceTimePoint())
            {

                std::vector<Bounds> v = edge0->getIntervals();
                std::vector<Bounds>::iterator it = v.begin();
                IntervalConstraint::Ptr i(new IntervalConstraint(source, target));
                while (it!=v.end())
                {
                    /* edge1: [x--------------y]
                        edge0:   [a-------b]
                        => add:  [a-------b]
                    */
                    if (interval->getLowerBound() <= it->getLowerBound() && interval->getUpperBound() >= it->getUpperBound())
                    {
                        i->addInterval(Bounds(it->getLowerBound(),it->getUpperBound()));
                    }
                    else
                    /*  edge1: [x------------y]
                        edge0:      [a------------b]
                        => add:     [a-------y]
                    */
                    if (interval->getLowerBound() <= it->getLowerBound() && interval->getUpperBound() <= it->getUpperBound())
                    {
                        if (it->getLowerBound() <= interval->getUpperBound())
                        {
                            i->addInterval(Bounds(it->getLowerBound(),interval->getUpperBound()));
                        }
                    }
                    else
                    /*  edge1:        [x-----------y]
                        edge0:    [a---------b]
                        => add:       [x-----b]
                    */
                    if (interval->getLowerBound() >= it->getLowerBound() && interval->getUpperBound() >= it->getUpperBound())
                    {
                        if (it->getUpperBound() >= interval->getLowerBound())
                        {
                            i->addInterval(Bounds(interval->getLowerBound(),it->getUpperBound()));
                        }
                    }
                    else
                    /*  edge1:     [x----y]
                        edge0:  [a-----------b]
                        => add:    [x----y]
                    */
                    if (interval->getLowerBound() >= it->getLowerBound() && interval->getUpperBound() <= it->getUpperBound())
                    {
                        i->addInterval(Bounds(interval->getLowerBound(),interval->getUpperBound()));
                    }
                    // otherwise:
                    /*  edge1:  [x----y]
                        edge0:            [a----b]
                        or
                        edge1:            [x----y]
                        edge0:  [a----b]
                        => we don't add anything
                    */
                    it++;
                }
                tcn.addIntervalConstraint(i);
            }
        }
    }
    mpDistanceGraph = tcn.mpDistanceGraph->copy();
    // update mpDistanceGraph with the one that we just created (tcn)
    return mpDistanceGraph;
}

// Change A ------[lowerBound,uppperBound]------> B into:
/*
 *           A --- weight:   upper bound --> B
 *           B --- weight: - lower bound --> A
 *  Upper and lower bounds of each interval are added as edges in forward and backward direction between two edges
 *   Returns the weighted graph
**/
graph_analysis::BaseGraph::Ptr TemporalConstraintNetwork::toWeightedGraph()
{
    BaseGraph::Ptr graph = BaseGraph::getInstance();
    BaseGraph::Ptr tcn = mpDistanceGraph->copy();
    EdgeIterator::Ptr edgeIt = tcn->getEdgeIterator();

    while (edgeIt->next())
    {
        IntervalConstraint::Ptr edge0 = dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );

        std::vector<Bounds> intervals = edge0->getIntervals();
        std::vector<Bounds>::const_iterator cit = intervals.begin();
        for( ; cit != intervals.end(); ++cit)
        {
            WeightedEdge::Ptr forwardEdge(new WeightedEdge(cit->getUpperBound()));
            forwardEdge->setSourceVertex(edge0->getSourceTimePoint());
            forwardEdge->setTargetVertex(edge0->getTargetTimePoint());
            graph->addEdge(forwardEdge);

            WeightedEdge::Ptr reverseEdge(new WeightedEdge(-cit->getLowerBound()));
            reverseEdge->setSourceVertex(edge0->getTargetTimePoint());
            reverseEdge->setTargetVertex(edge0->getSourceTimePoint());
            graph->addEdge(reverseEdge);
        }
    }

    return graph;
}

//compute the minimal network of a simple temporal network using Floyd-Warshall
void TemporalConstraintNetwork::minNetwork()
{
    // Input: a simple temporal constraint network
    TemporalConstraintNetwork tcn;
    // Change its graph into a weighted graph and then apply Floyd-Warshall
    BaseGraph::Ptr graph = (toWeightedGraph())->copy();

    BaseGraph::Ptr oldGraph = mpDistanceGraph->copy();
    algorithms::DistanceMatrix distanceMatrix = algorithms::FloydWarshall::allShortestPaths(graph, [](Edge::Ptr e) -> double
                {
                    return dynamic_pointer_cast<WeightedEdge>(e)->getWeight();
                });
    EdgeIterator::Ptr edgeIt = oldGraph->getEdgeIterator();

    // Change again the computed graph into a graph using Interval Constraint representation
    TimePoint::Ptr v1,v2;
    while (edgeIt->next())
    {
        IntervalConstraint::Ptr edge = dynamic_pointer_cast<IntervalConstraint>(edgeIt->current());
        v1 = edge->getSourceTimePoint();
        v2 = edge->getTargetTimePoint();

        double distance12 = distanceMatrix[std::pair<TimePoint::Ptr, TimePoint::Ptr>(v1,v2)];
        double distance21 = distanceMatrix[std::pair<TimePoint::Ptr, TimePoint::Ptr>(v2,v1)];
        distance21 = (-1)*distance21;
        IntervalConstraint::Ptr i(new IntervalConstraint(v1, v2));
        i->addInterval(Bounds(distance21,distance12));
        tcn.addIntervalConstraint(i);
    }
    // update mpDistanceGraph with the one that we just created (a simple temporal constraint network with the shortest paths computed)
    mpDistanceGraph = tcn.mpDistanceGraph->copy();
}

bool TemporalConstraintNetwork::equals(const graph_analysis::BaseGraph::Ptr& other)
{
    // check if the graphs have the same number of vertices and edges
    if (mpDistanceGraph->size() != other->size() || mpDistanceGraph->order() != other->order())
    {
        LOG_WARN_S << "Expected size: " << mpDistanceGraph->size() << " order: " << mpDistanceGraph->order()
            << " got other with: size:" << other->size() << " order: " << other->order();
        return false;
    }

    Vertex::PtrList allVertices = mpDistanceGraph->getAllVertices();
    numeric::Combination<Vertex::Ptr> combination(allVertices, 2, numeric::EXACT);
    do
    {
        const Vertex::PtrList& edge = combination.current();
        const point_algebra::TimePoint::Ptr& sourceTimePoint = dynamic_pointer_cast<point_algebra::TimePoint>(edge[0]);
        const point_algebra::TimePoint::Ptr& targetTimePoint = dynamic_pointer_cast<point_algebra::TimePoint>(edge[1]);

        std::vector<graph_analysis::Edge::Ptr> thisEdgeList, otherEdgeList;
        thisEdgeList = mpDistanceGraph->getEdges(sourceTimePoint,targetTimePoint);
        otherEdgeList = other->getEdges(sourceTimePoint,targetTimePoint);

        Bounds::List thisIntervals;
        Bounds::List otherIntervals;

        if(!thisEdgeList.empty())
        {
            IntervalConstraint::Ptr thisEdge = dynamic_pointer_cast<IntervalConstraint>(thisEdgeList.front());
            thisIntervals.insert(thisIntervals.begin(), thisEdge->getIntervals().begin(), thisEdge->getIntervals().end());
        }
        if(!otherEdgeList.empty())
        {
            IntervalConstraint::Ptr otherEdge = dynamic_pointer_cast<IntervalConstraint>(otherEdgeList.front());
            otherIntervals.insert(otherIntervals.begin(), otherEdge->getIntervals().begin(), otherEdge->getIntervals().end());
        }

        // check reverse
        thisEdgeList = mpDistanceGraph->getEdges(targetTimePoint, sourceTimePoint);
        otherEdgeList = other->getEdges(targetTimePoint, sourceTimePoint);
        if(!thisEdgeList.empty())
        {
            IntervalConstraint::Ptr edge = dynamic_pointer_cast<IntervalConstraint>(thisEdgeList.front());
            Bounds::List intervals = Bounds::reverse( edge->getIntervals() );
            thisIntervals.insert(thisIntervals.begin(), intervals.begin(), intervals.end());
        }
        if(!otherEdgeList.empty())
        {
            IntervalConstraint::Ptr edge = dynamic_pointer_cast<IntervalConstraint>(otherEdgeList.front());
            Bounds::List intervals = Bounds::reverse( edge->getIntervals() );
            otherIntervals.insert(otherIntervals.begin(), intervals.begin(), intervals.end());
        }

        if(!Bounds::equals(thisIntervals, otherIntervals))
        {
            LOG_WARN_S << "From: " << sourceTimePoint->getLabel()
                << " to: " << targetTimePoint->getLabel() << std::endl << " BOUNDS are not equal: " << Bounds::toString(thisIntervals) << " vs "
                << Bounds::toString(otherIntervals) << std::endl;

            return false;
        }

    } while(combination.next());

    return true;
}

// Upper-Lower-Tightening Algorithm
void TemporalConstraintNetwork::upperLowerTightening()
{
    BaseGraph::Ptr oldGraph;
    do
    {
        // oldGraph = newGraph
        oldGraph = mpDistanceGraph->copy();
        stp();
        minNetwork();

        // copy oldGraph into a temporal constraint network
        TemporalConstraintNetwork tcn;

        // newGraph becomes the minimal network
        EdgeIterator::Ptr edgeIt = oldGraph->getEdgeIterator();
        while (edgeIt->next())
        {
            IntervalConstraint::Ptr intervalConstraint = dynamic_pointer_cast<IntervalConstraint>(edgeIt->current());
            tcn.addIntervalConstraint(intervalConstraint);
        }

        // apply intersection for oldGraph and newGraph(minimal network)
        tcn.intersection(mpDistanceGraph);
        // newGraph becomes the resulted graph obtained from the intersection between the oldGraph and the minimal network
        mpDistanceGraph = tcn.mpDistanceGraph->copy();
    } while (!this->equals(oldGraph)); // until newGraph = oldGraph
}

int TemporalConstraintNetwork::getEdgeNumber()
{
    return mpDistanceGraph->size();
}

void TemporalConstraintNetwork::save(const std::string& filename) const
{
    if(!getGraph()->empty())
    {
        graph_analysis::io::GraphIO::write(filename, getGraph(), graph_analysis::representation::GRAPHVIZ);
        graph_analysis::io::GraphIO::write(filename, getGraph(), graph_analysis::representation::GEXF);
    }

    if(!getDistanceGraph()->empty())
    {
        graph_analysis::io::GraphIO::write(filename + "-distance_graph", getDistanceGraph(), graph_analysis::representation::GRAPHVIZ);
        graph_analysis::io::GraphIO::write(filename + "-distance_graph", getDistanceGraph(), graph_analysis::representation::GEXF);
    }
}


void TemporalConstraintNetwork::sort(std::vector<point_algebra::TimePoint::Ptr>& timepoints) const
{
    const QualitativeTemporalConstraintNetwork* qtcn = dynamic_cast<const QualitativeTemporalConstraintNetwork*>(this);
    if(qtcn)
    {
        solvers::csp::TemporalConstraintNetwork::sort(*qtcn, timepoints);
    } else {
        // allow using of shared pointer like normal pointers, when auto-deleting is not
        // desirable
        TemporalConstraintNetwork::Ptr tcn(const_cast<TemporalConstraintNetwork*>(this), [](TemporalConstraintNetwork*){});
        TimePointComparator comparator(tcn);
        comparator.sort(timepoints);
    }
}

void TemporalConstraintNetwork::setConsistentNetwork(const graph_analysis::BaseGraph::Ptr& baseGraph)
{
    setGraph(baseGraph);
}

point_algebra::TimePoint::Ptr TemporalConstraintNetwork::getTimePoint(const std::string& name) const
{
    using namespace solvers::temporal::point_algebra;

    graph_analysis::VertexIterator::Ptr it = getVariableIterator();
    while(it->next())
    {
        QualitativeTimePoint::Ptr t = dynamic_pointer_cast<QualitativeTimePoint>(it->current());
        if(t && t->getLabel() == name)
        {
            return t;
        }
    }
    throw std::invalid_argument("templ::solvers::temporal::TemporalConstraintNetwork::getTimePoint: timepoint with label '" + name + "'"
            " not found");
}

point_algebra::TimePoint::Ptr TemporalConstraintNetwork::getOrCreateTimePoint(const std::string& name) const
{
    using namespace solvers::temporal::point_algebra;
    TimePoint::Ptr timepoint;
    try {
        return getTimePoint(name);
    } catch(const std::invalid_argument& e)
    {
        try {
            if(name == "inf")
            {
                return TimePoint::create(std::numeric_limits<uint64_t>::infinity(), std::numeric_limits<uint64_t>::infinity());
            } else {
                uint64_t exactTime = boost::lexical_cast<uint64_t>(name);
                return TimePoint::create(exactTime, exactTime);
            }
        } catch(const std::bad_cast& e)
        {
            return TimePoint::create(name);
        }
    }

    throw std::runtime_error("templ::solvers::temporal::TemporalConstraintNetwork::getOrCreateTimePoint: timepoint with label/value '" + name + "' could neither be found nor created");
}

std::string TemporalConstraintNetwork::toString(uint32_t indent) const
{
    std::stringstream ss;
    std::string hspace(indent,' ');

    using namespace solvers::temporal::point_algebra;
    graph_analysis::EdgeIterator::Ptr it = getConstraintIterator();
    while(it->next())
    {
        QualitativeTimePointConstraint::Ptr t = dynamic_pointer_cast<QualitativeTimePointConstraint>(it->current());
        if(t)
        {
            ss << t->toString(indent);
        }
    }
    return ss.str();
}

point_algebra::TimePoint::PtrList TemporalConstraintNetwork::getTimepoints() const
{
    using namespace graph_analysis;
    std::vector<solvers::temporal::point_algebra::TimePoint::Ptr> timepoints;

    VertexIterator::Ptr vertexIt = getGraph()->getVertexIterator();
    while(vertexIt->next())
    {
        solvers::temporal::point_algebra::TimePoint::Ptr tp =
            dynamic_pointer_cast<solvers::temporal::point_algebra::TimePoint>(vertexIt->current());
        timepoints.push_back(tp);
    }

    sort(timepoints);
    return timepoints;
}

TemporalConstraintNetwork::Assignment TemporalConstraintNetwork::getAssignment() const
{
    TimePoint::PtrList timepoints;
    std::map<point_algebra::TimePoint::Ptr, double> lowerBounds;
    TimePoint::Ptr startPoint;
    VertexIterator::Ptr vertexIt = mpDistanceGraph->getVertexIterator();
    while(vertexIt->next())
    {
        TimePoint::Ptr tp = dynamic_pointer_cast<TimePoint>(vertexIt->current());
        timepoints.push_back(tp);

        if(mpDistanceGraph->getInEdges(tp).empty())
        {
            if(!startPoint)
            {
                startPoint = tp;
            } else
            {
                throw
                    std::runtime_error("TemporalConstraintNetwork::getAssignment:" \
                            "start point already set" + startPoint->toString() +
                            " vs. " + tp->toString() );
            }
        }
    }

    if(timepoints.empty())
    {
        throw std::invalid_argument("TemporalConstraintNetwork::getAssignment: empty list of timepoints");
    }

    if(!startPoint)
    {
        throw std::invalid_argument("TemporalConstraintNetwork::getAssignment:" \
                "no start timepoint identified");
    }

    // Compute the time horizon
    double timeHorizonInS = 0.0;
    TimePoint::Ptr evalTimepoint = startPoint;
    while(true)
    {
        lowerBounds[ evalTimepoint ] = timeHorizonInS;
        {
            Edge::PtrList edges =
                mpDistanceGraph->getOutEdges(evalTimepoint);

            if(edges.empty())
            {
                // final timepoint found
                break;
            }

            TimePoint::Ptr nextTp;
            double nextTpDistance = std::numeric_limits<double>::max();
            for(const Edge::Ptr& e : edges)
            {
                IntervalConstraint::Ptr intervalConstraint = dynamic_pointer_cast<IntervalConstraint>(e);
                double interval = intervalConstraint->getLowerBound();

                if(interval < nextTpDistance)
                {
                    nextTpDistance = interval;
                    nextTp = intervalConstraint->getTargetTimePoint();
                }
            }
            evalTimepoint = nextTp;
            timeHorizonInS += nextTpDistance;
        }
    }
    return lowerBounds;
}

double TemporalConstraintNetwork::getTimeHorizon(const Assignment& assignments)
{
    double horizon = 0;
    for(const Assignment::value_type& p : assignments)
    {
        if(p.second > horizon)
        {
            horizon = p.second;
        }
    }
    return horizon;
}

void TemporalConstraintNetwork::addIntervalConstraint(const IntervalConstraint::Ptr& i)
{
    if( !i->getSourceVertex()->associated( mpDistanceGraph->getId()) ||
            !i->getTargetVertex()->associated( mpDistanceGraph->getId()) )
    {
        mpDistanceGraph->addEdge(i);
        return;
    }

    Edge::PtrList edges = mpDistanceGraph->getEdges(i->getSourceVertex(), i->getTargetVertex());
    if(edges.empty())
    {
        mpDistanceGraph->addEdge(i);
    } else {
        IntervalConstraint::Ptr ic = dynamic_pointer_cast<IntervalConstraint>(*edges.begin());
        if(!ic)
        {
            throw std::runtime_error("TemporalConstraintNetwork: conversion to interval constraint failed");
        }

        for(const Bounds& bounds : i->getIntervals())
        {
            ic->addInterval(bounds);
        }
    }
}

} // end namespace temporal
} // end namespace solvers
} // end namespace templ
